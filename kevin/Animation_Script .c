
// this ver used in final, U1 POV

// THIS VER IS THE ONE  THAT WORKS BEST NOW keep SAFE...........

#include <fix_fft.h>

char rc;
char endMarker = '\n' ;// clear buffer from TTY and Telco


int inPin = 0;
int val2 = 0;
boolean povRunning1 = false;
boolean povRunning2 = false;
boolean newData = false;

int offsetValue = -20;
const byte numChars = 32;
const int BUFFER_LENGTH2 = 60;
const int BUFFER_LENGTH = 64;
const int R_IN = A1;// fft
const int HomeSw = 2;
const int NUM_HORIZONTAL_POSITIONS = BUFFER_LENGTH / 2;
const int NUM_LED_HOLD_POSITIONS = 10;// was 8
const int Status_led = 12;
const int homeLed = 13;
const int DiagLed = 14;
const int time1 = 600;// use for larg spectrum determins how "wide" the display is
const int time2 = 0; // use for small spectrum determins how "wide" the display is

char Rdata[BUFFER_LENGTH];// fft
char Rim[BUFFER_LENGTH];// fft
char data_avgs[BUFFER_LENGTH / 2];
char textString[] = ".      Waiting for SERIAL     .  ";
char receivedChars[numChars];
char buffer[BUFFER_LENGTH2];

int time0 = 0;// use for spectrum temp holder
int LED_PINS[] = {10, 3, 4, 5, 6, 7, 8, 9};// led order
int length = 75;

String mydata;

const unsigned char font[][6] = {
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //   0x20 0
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //   0x20 1
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //   0x20 2
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //   0x20 3
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //   0x20 4
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //   0x20 5
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //   0x20 6
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //   0x20 7
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //   0x20 8
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //   0x20 9
  {0x7f, 0x3e, 0x1c, 0x08, 0x08, 0x0f}, //   0x0a 10 // LF/NL
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //   0x20 11
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //   0x20 12
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //   0x20 13
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //   0x20 14
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //   0x20 15
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //   0x20 16
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //   0x20 17
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //   0x20 18
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //   0x20 19
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //   0x20 20
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //   0x20 21
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //   0x20 22
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //   0x20 23
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //   0x20 24
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //   0x20 25
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //   0x20 26
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //   0x20 27
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //   0x20 28
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //   0x20 29
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //   0x20 30
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //   0x20 31
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //   0x20 32
  {0x00, 0x00, 0x6f, 0x00, 0x00, 0x00}, // ! 0x21 33
  {0x00, 0x07, 0x00, 0x07, 0x00, 0x00}, // " 0x22 34
  {0x14, 0x7f, 0x14, 0x7f, 0x14, 0x00}, // # 0x23 35
  {0x00, 0x07, 0x04, 0x1e, 0x00, 0x00}, // $ 0x24 36
  {0x23, 0x13, 0x08, 0x64, 0x62, 0x00}, // % 0x25 37
  {0x36, 0x49, 0x56, 0x20, 0x50, 0x00}, // & 0x26 38
  {0x00, 0x00, 0x07, 0x00, 0x00, 0x00}, // ' 0x27 39
  {0x00, 0x1c, 0x22, 0x41, 0x00, 0x00}, // ( 0x28 40
  {0x00, 0x41, 0x22, 0x1c, 0x00, 0x00}, // ) 0x29 41
  {0x14, 0x08, 0x3e, 0x08, 0x14, 0x00}, // * 0x2a 42
  {0x08, 0x08, 0x3e, 0x08, 0x08, 0x00}, // + 0x2b 43
  {0x00, 0x50, 0x30, 0x00, 0x00, 0x00}, // , 0x2c 44
  {0x08, 0x08, 0x08, 0x08, 0x08, 0x00}, // - 0x2d 45
  {0x00, 0x60, 0x60, 0x00, 0x00, 0x00}, // . 0x2e 46
  {0x20, 0x10, 0x08, 0x04, 0x02, 0x00}, // / 0x2f 47
  {0x3e, 0x51, 0x49, 0x45, 0x3e, 0x00}, // 0 0x30 48
  {0x00, 0x42, 0x7f, 0x40, 0x00, 0x00}, // 1 0x31 49
  {0x42, 0x61, 0x51, 0x49, 0x46, 0x00}, // 2 0x32 50
  {0x21, 0x41, 0x45, 0x4b, 0x31, 0x00}, // 3 0x33 51
  {0x18, 0x14, 0x12, 0x7f, 0x10, 0x00}, // 4 0x34 52
  {0x27, 0x45, 0x45, 0x45, 0x39, 0x00}, // 5 0x35 53
  {0x3c, 0x4a, 0x49, 0x49, 0x30, 0x00}, // 6 0x36 54
  {0x01, 0x71, 0x09, 0x05, 0x03, 0x00}, // 7 0x37 55
  {0x36, 0x49, 0x49, 0x49, 0x36, 0x00}, // 8 0x38 56
  {0x06, 0x49, 0x49, 0x29, 0x1e, 0x00}, // 9 0x39 57
  {0x00, 0x36, 0x36, 0x00, 0x00, 0x00}, // : 0x3a 58
  {0x00, 0x56, 0x36, 0x00, 0x00, 0x00}, // ; 0x3b 59
  {0x08, 0x14, 0x22, 0x41, 0x00, 0x00}, // < 0x3c 60
  {0x14, 0x14, 0x14, 0x14, 0x14, 0x00}, // = 0x3d 61
  {0x00, 0x41, 0x22, 0x14, 0x08, 0x00}, // > 0x3e 62
  {0x02, 0x01, 0x51, 0x09, 0x06, 0x00}, // ? 0x3f 63
  {0x3e, 0x41, 0x5d, 0x49, 0x4e, 0x00}, // @ 0x40 64
  {0x7e, 0x09, 0x09, 0x09, 0x7e, 0x00}, // A 0x41 65
  {0x7f, 0x49, 0x49, 0x49, 0x36, 0x00}, // B 0x42 66
  {0x3e, 0x41, 0x41, 0x41, 0x22, 0x00}, // C 0x43 67
  {0x7f, 0x41, 0x41, 0x41, 0x3e, 0x00}, // D 0x44 68
  {0x7f, 0x49, 0x49, 0x49, 0x41, 0x00}, // E 0x45 69
  {0x7f, 0x09, 0x09, 0x09, 0x01, 0x00}, // F 0x46 70
  {0x3e, 0x41, 0x49, 0x49, 0x7a, 0x00}, // G 0x47 71
  {0x7f, 0x08, 0x08, 0x08, 0x7f, 0x00}, // H 0x48 72
  {0x00, 0x41, 0x7f, 0x41, 0x00, 0x00}, // I 0x49 73
  {0x20, 0x40, 0x41, 0x3f, 0x01, 0x00}, // J 0x4a 74
  {0x7f, 0x08, 0x14, 0x22, 0x41, 0x00}, // K 0x4b 75
  {0x7f, 0x40, 0x40, 0x40, 0x40, 0x00}, // L 0x4c 76
  {0x7f, 0x02, 0x0c, 0x02, 0x7f, 0x00}, // M 0x4d 77
  {0x7f, 0x04, 0x08, 0x10, 0x7f, 0x00}, // N 0x4e 78
  {0x3e, 0x41, 0x41, 0x41, 0x3e, 0x00}, // O 0x4f 79
  {0x7f, 0x09, 0x09, 0x09, 0x06, 0x00}, // P 0x50 80
  {0x3e, 0x41, 0x51, 0x21, 0x5e, 0x00}, // Q 0x51 81
  {0x7f, 0x09, 0x19, 0x29, 0x46, 0x00}, // R 0x52 82
  {0x46, 0x49, 0x49, 0x49, 0x31, 0x00}, // S 0x53 83
  {0x01, 0x01, 0x7f, 0x01, 0x01, 0x00}, // T 0x54 84
  {0x3f, 0x40, 0x40, 0x40, 0x3f, 0x00}, // U 0x55 85
  {0x0f, 0x30, 0x40, 0x30, 0x0f, 0x00}, // V 0x56 86
  {0x3f, 0x40, 0x30, 0x40, 0x3f, 0x00}, // W 0x57 87
  {0x63, 0x14, 0x08, 0x14, 0x63, 0x00}, // X 0x58 88
  {0x07, 0x08, 0x70, 0x08, 0x07, 0x00}, // Y 0x59 89
  {0x61, 0x51, 0x49, 0x45, 0x43, 0x00}, // Z 0x5a 90
  {0x3c, 0x4a, 0x49, 0x29, 0x1e, 0x00}, // [ 0x5b 91
  {0x02, 0x04, 0x08, 0x10, 0x20, 0x00}, // \ 0x5c 92
  {0x00, 0x41, 0x7f, 0x00, 0x00, 0x00}, // ] 0x5d 93
  {0x04, 0x02, 0x01, 0x02, 0x04, 0x00}, // ^ 0x5e 94
  {0x40, 0x40, 0x40, 0x40, 0x40, 0x00}, // _ 0x5f 95
  {0x00, 0x00, 0x03, 0x04, 0x00, 0x00}, // ` 0x60 96
  {0x20, 0x54, 0x54, 0x54, 0x78, 0x00}, // a 0x61 97
  {0x7f, 0x48, 0x44, 0x44, 0x38, 0x00}, // b 0x62 98
  {0x38, 0x44, 0x44, 0x44, 0x20, 0x00}, // c 0x63 99
  {0x38, 0x44, 0x44, 0x48, 0x7f, 0x00}, // d 0x64 100
  {0x38, 0x54, 0x54, 0x54, 0x18, 0x00}, // e 0x65 101
  {0x08, 0x7e, 0x09, 0x01, 0x02, 0x00}, // f 0x66 102
  {0x0c, 0x52, 0x52, 0x52, 0x3e, 0x00}, // g 0x67 103
  {0x7f, 0x08, 0x04, 0x04, 0x78, 0x00}, // h 0x68 104
  {0x00, 0x44, 0x7d, 0x40, 0x00, 0x00}, // i 0x69 105
  {0x20, 0x40, 0x44, 0x3d, 0x00, 0x00}, // j 0x6a 106
  {0x00, 0x7f, 0x10, 0x28, 0x44, 0x00}, // k 0x6b 107
  {0x00, 0x41, 0x7f, 0x40, 0x00, 0x00}, // l 0x6c 108
  {0x7c, 0x04, 0x18, 0x04, 0x78, 0x00}, // m 0x6d 109
  {0x7c, 0x08, 0x04, 0x04, 0x78, 0x00}, // n 0x6e 110
  {0x38, 0x44, 0x44, 0x44, 0x38, 0x00}, // o 0x6f 111
  {0x7c, 0x14, 0x14, 0x14, 0x08, 0x00}, // p 0x70 112
  {0x08, 0x14, 0x14, 0x18, 0x7c, 0x00}, // q 0x71 113
  {0x7c, 0x08, 0x04, 0x04, 0x08, 0x00}, // r 0x72 114
  {0x48, 0x54, 0x54, 0x54, 0x20, 0x00}, // s 0x73 115
  {0x04, 0x3f, 0x44, 0x40, 0x20, 0x00}, // t 0x74 116
  {0x3c, 0x40, 0x40, 0x20, 0x7c, 0x00}, // u 0x75 117
  {0x1c, 0x20, 0x40, 0x20, 0x1c, 0x00}, // v 0x76 118
  {0x3c, 0x40, 0x30, 0x40, 0x3c, 0x00}, // w 0x77 119
  {0x44, 0x28, 0x10, 0x28, 0x44, 0x00}, // x 0x78 120
  {0x0c, 0x50, 0x50, 0x50, 0x3c, 0x00}, // y 0x79 121
  {0x44, 0x64, 0x54, 0x4c, 0x44, 0x00}, // z 0x7a 122
  {0x00, 0x08, 0x36, 0x41, 0x41, 0x00}, // { 0x7b 123
  {0x00, 0x00, 0x7f, 0x00, 0x00, 0x00}, // | 0x7c 124
  {0x41, 0x41, 0x36, 0x08, 0x00, 0x00}, // } 0x7d 125
  {0x04, 0x02, 0x04, 0x08, 0x04, 0x00}, // ~ 0x7e 126
};


void setup() {
  Serial.begin(9600);
  pinMode(Status_led, OUTPUT);
  pinMode(homeLed, OUTPUT);
  pinMode(DiagLed, OUTPUT);
  digitalWrite(DiagLed, HIGH);
  pinMode(HomeSw, INPUT);

  pinMode(3, OUTPUT);
  pinMode(4, OUTPUT);
  pinMode(5, OUTPUT);
  pinMode(6, OUTPUT);
  pinMode(7, OUTPUT);
  pinMode(8, OUTPUT);
  pinMode(9, OUTPUT);
  pinMode(10, OUTPUT);
  pinMode(12, OUTPUT); // Set pin 12 as output
 

  // Flash LED D12 three(k) times
  for (int i = 0; i < 3000; i++) {
    digitalWrite(12, HIGH); // Turn on LED
    delayMicroseconds(100);
    digitalWrite(12, LOW); // Turn off LED
    delayMicroseconds(300);

  }

  digitalWrite(DiagLed, HIGH); // Turn OFF LED i/o 14
  // Set up initial message
  //------------------------------------------------------------------------------------------------------------------------------------------------------------
  mydata = "                                                           Booting UP ~~~~~ Tachyscope LASER POV ,   NVictria technology  V2.0, 9600 baud              "; // 60 spaces LASER
  //-------------------------------------------------------------------------------------------------------------------------------------------------------------
  leds_display(); // Display message once upon boot-up
}

void loop() {
  recvWithEndMarker();
  if (povRunning1 && !povRunning2) {
    Spectrum1(); // large
  }
  else if (povRunning2 && !povRunning1) {
    Spectrum2(); // small
  }
  else {
    loop2(); // for SW3 to SW9 POV +++++++++ TRIGGER
  }
}

void recvWithEndMarker() {
  static byte ndx = 0;
  const char endMarker = '\n'; // Change to const
  char rc;

  while (Serial.available() > 0) {
    rc = Serial.read();
    if (rc != endMarker) {
      if (ndx < numChars - 1) {
        receivedChars[ndx++] = rc;
      }
    } else {
      receivedChars[ndx] = '\0'; // terminate the string
      parseData();
      ndx = 0;
      newData = true;
      return; // Exit the function after processing one message
    }
  }
}


// scrolling routine at bootup
void leds_display()// original keep
{
  int temp = mydata.length();
  while (temp != 0)
  {
    rotateFrame();
    temp--;
    HOMEsw();
  }
  for (int i = sizeof(textString) - 1; i >= 0; i--) {
    String1();
  }
}


void Spectrum1() {// sw 1= large spectrum
  readAudioData();
  processData();
  updateLEDs();// large spectrum spacing
  ClearDisplay();
}

void Spectrum2() {// sw2 = small spectrum
  readAudioData();
  processData();
  //updateLEDs();
  updateLEDsSW3();// put spaces between bins, small spectrum spacing
  ClearDisplay();
}
void loop2() {
  showNewData();
}

void readAudioData() {
  
  while (digitalRead(HomeSw) != 0);// was 0
  for (int i = 0; i < BUFFER_LENGTH ; i++) {
   Rdata[i] = ((analogRead(R_IN) / 8) - 128);// nice
  }
  fix_fft(Rdata, Rim, 6, 0);// original
}

void processData() {// now both process and mirror as 1 routine
  // First, process the data.
  for (int i = 0; i < NUM_HORIZONTAL_POSITIONS; i++) {
    data_avgs[i] = sqrt(Rdata[i] * Rdata[i] + Rim[i] * Rim[i]);
  }
  // Then, mirror the data.
  for (int i = 0; i < NUM_HORIZONTAL_POSITIONS / 2; i++) {
    char temp = data_avgs[i];
    data_avgs[i] = data_avgs[NUM_HORIZONTAL_POSITIONS - i - 1];
    data_avgs[NUM_HORIZONTAL_POSITIONS - i - 1] = temp;
  }
}
// below for small spectrum
void updateLEDsSW3() {// this ver puts space between bar graphs
  for (int pos = 0; pos < NUM_HORIZONTAL_POSITIONS -1; pos++) {// original (-1) removes leftside index
    int peakValue = static_cast<int>(data_avgs[pos]);
    for (int i = 0; i < NUM_LED_HOLD_POSITIONS; i++) { // original
      digitalWrite(LED_PINS[i], peakValue > 9 - i); // flips display top to bottom (9 leds) POV drop the bottom led so that no leds ON when no audio
      digitalWrite(12, HIGH);// blue led at bottom
    }
    // Space between segments
    delayMicroseconds(100); // Adjust this value to increase/decrease space
    // 200 is good
    // Turn off the LEDs to create the space effect
    for (int i = 0; i < NUM_LED_HOLD_POSITIONS; i++) {
      digitalWrite(LED_PINS[i], LOW);
      digitalWrite(12, LOW);
    }
    // Delay before moving to the next position
    delayMicroseconds(time0);
  }
}


void updateLEDs() {// keep original spectrum LARGE
  for (int pos = 0; pos < NUM_HORIZONTAL_POSITIONS - 1 ; pos++) {
    int peakValue = static_cast<int>(data_avgs[pos]);
    {
      for (int i = 0 ; i < NUM_LED_HOLD_POSITIONS  ; i++) { // original
        digitalWrite(LED_PINS[i], peakValue > 9 - i); // flips display top to bottom
        digitalWrite(12, HIGH);// blue led at bottom
        digitalWrite(12, HIGH);// x 3 for length of ON time
        digitalWrite(12, HIGH);
      }
    }
    delayMicroseconds(time0);
    digitalWrite(12, LOW);
  }
}

void parseData() {// ( space Sw1) to activate spectrum// keep
  char messageFromPC[numChars]; // variable to hold the message from PC
  char numberFromPC[numChars];  // variable to hold the number from PC

  char *strtokIndx; // this is used by strtok() as an index
  char tempChars[numChars]; // temporary array to hold received data

  strcpy(tempChars, receivedChars);
  strtokIndx = strtok(tempChars, ",");     // get the first part - the string
  strcpy(messageFromPC, strtokIndx); // copy it to messageFromPC
  strtokIndx = strtok(NULL, ","); // this continues where the previous call left off
  if (strtokIndx != NULL) {
    strcpy(numberFromPC, strtokIndx);     // convert this part to an integer
  }

  if (strcmp(messageFromPC, " Sw1") == 0) { // Check if the message is " Space Sw1"
    povRunning1 = true; // Activate Spectrum Large routine
    povRunning2 = false; // De-Activate Spectrum smallroutine
  } else if (strncmp(messageFromPC, " Sw", 3) == 0) { // Check if the message starts with " Sw"
    int num = 0;
    if (sscanf(messageFromPC, " Sw%d", &num) == 1) { // Extract the number after " Sw"
      if (num == 1) { // Check if the parsed number is equal to 1
        povRunning1 = true; // Activate Spectrum Large routine
        povRunning2 = false; // De-Activate Spectrum smallroutine
        time0 = time1;// large display
      }
      if (num == 2) { // Check if the parsed number is equal to 1
        povRunning1 = false; // Activate Spectrum Large routine
        povRunning2 = true; // De-Activate Spectrum smallroutine
        time0 = time2;// small display
      }
      else if (num > 2) { // Check if the parsed number larger than 2
        povRunning1 = false; // Activate Spectrum Large routine
        povRunning2 = false; // De-Activate Spectrum smallroutine
         offsetValue = -35;// use for Sw3-Sw10, move to center right
      }
    }
  }
  // If both routines are false, pass the serial over to the POV
  if (!povRunning1 && !povRunning2) {
    // Code to pass serial data over to the POV
    // For example:
    //Serial.print("Passing serial data over to the POV: ");
    // Serial.println(receivedChars);
    // loop2();// run sw3 to 10 POV
    // return; // Exit the function after processing one message
  }
}


void rotateFrame()
{
  char temp = mydata[0];
  for (int i = 0; i < mydata.length() - 1; i++) {
    mydata[i] = mydata[i + 1];
  }
  mydata[mydata.length() - 1] = temp;
}


void HOMEsw()
{
  while (digitalRead(HomeSw) != 0);// laser was 0
    for (int y = length + offsetValue; y > -1; y--)// offset= how far to shift text to center, -20 or -35
  {
    printLetter(mydata[y]);
  }
  // Turn off LEDs representing preceding characters
  for (int i = 0; i < 20; i++) {
    // Turn off each LED column
    for (int row = 0; row < 8; row++) {
      digitalWrite(LED_PINS[row], LOW);
    }
    delayMicroseconds(8); // Adjust if needed
  }
}

void String1()// Static message 1
{
  for (int y = sizeof(textString) + 3; y >= -1; y--) // WHITE +3 shift text to center of POV, 3 spots ***
  {
    printLetter(textString[y]);
  }
  while (digitalRead(HomeSw) != 0);// Laser was 0
}


void ClearDisplay() {
  for (int i = 0; i < NUM_LED_HOLD_POSITIONS; i++) {
    digitalWrite(LED_PINS[i], LOW);
  }
}


void showNewData() { 
  HOMEsw();
  if (newData == true)
  {
    mydata = receivedChars;
    newData = false;
  }
}

void printLetter(char data){ 
  for (int x = 5; x >= 0; x--)
  {
    char temp_data = font[data][x];
    for (int row = 0; row < 8; row++)
    {
      digitalWrite(LED_PINS[row], bitRead(temp_data, row));
      digitalWrite(12, HIGH);// blue led at bottom
    }
    delayMicroseconds(55); // space between char
    digitalWrite(12, LOW);// blue led at bottom
  }
  led1();
}


void led1() {// serial GREEN led5
  val2 = digitalRead(inPin);   // read the RX serial input, copy RX in to led5
  digitalWrite(DiagLed, val2);  // set led on/off to Hi/Low of serial
  digitalWrite(DiagLed, val2);  // set led  a second time to make brighter
}
